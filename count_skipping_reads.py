import sys, itertools, optparse, warnings

optParser = optparse.OptionParser( 
   
   usage = "python %prog [options] <flattened_gff_file> <sam_file> <output_alternative_counts>",
   
   description=
      "This script counts how many reads in <sam_file> support exon skipping of each exonic " +
      "part given in <flattened_gff_file> and outputs a list of counts in " +
      "<output_file>, for further analysis with the DEXSeq Bioconductor package. " +
      "(Notes: The <flattened_gff_file> should be produced with the script " +
      "dexseq_prepare_annotation.py). <sam_file> may be '-' to indicate standard input.",
      
   epilog = 
      "Written by Alejandro Reyes" )
      
optParser.add_option( "-p", "--paired", type="choice", dest="paired",
   choices = ( "no", "yes" ), default = "no",
   help = "'yes' or 'no'. Indicates whether the data is paired-end (default: no)" )

optParser.add_option( "-s", "--stranded", type="choice", dest="stranded",
   choices = ( "yes", "no", "reverse" ), default = "yes",
   help = "'yes', 'no', or 'reverse'. Indicates whether the data is " +
      "from a strand-specific assay (default: yes ). " +
      "Be sure to switch to 'no' if you use a non strand-specific RNA-Seq library " +
      "preparation protocol. 'reverse' inverts strands and is neede for certain " +
      "protocols, e.g. paired-end with circularization."  )
   
optParser.add_option( "-a", "--minaqual", type="int", dest="minaqual",
   default = 10,
   help = "skip all reads with alignment quality lower than the given " +
      "minimum value (default: 10)" )

optParser.add_option( "-d", "--region", type="choice", dest="region",
   choices=("exonic_part_number", "bin_part_number"), default="exonic_part_number",
   help = "extra attribute to consider as exonic bin identifier" +
         "choose between exonic_part_number and bin_part_number")
   
if len( sys.argv ) == 1:
   optParser.print_help()
   sys.exit(1)

(opts, args) = optParser.parse_args()

if len( args ) != 3:
   sys.stderr.write( sys.argv[0] + ": Error: Please provide three arguments.\n" )
   sys.stderr.write( "  Call with '-h' to get usage information.\n" )
   sys.exit( 1 )

try:
   import HTSeq
except ImportError:
   sys.stderr.write( "Could not import HTSeq. Please install the HTSeq Python framework\n" )   
   sys.stderr.write( "available from http://www-huber.embl.de/users/anders/HTSeq\n" )   
   sys.exit(1)

gff_file = args[0]
sam_file = args[1]
out_alternative = args[2]

#gff_file = "/home/alejandro/SYSTEM/Mammals/annotations/annotationsDEXSeq/hsa.DEXSeq.gtf"
#sam_file = "/home/alejandro/SYSTEM/Mammals/sam/hsa-lv-M-1-hsa.unpaired_uniq"

stranded = opts.stranded == "yes" or opts.stranded == "reverse"
reverse = opts.stranded == "reverse"
stranded = False
is_PE = opts.paired == "yes"
minaqual = 0

if sam_file == "-":
   sam_file = sys.stdin


# Step 1: Read in the GFF file as generated by aggregate_genes.py
# and put everything into a GenomicArrayOfSets

transNames={}

features = HTSeq.GenomicArrayOfSets( "auto", stranded=stranded )     
print "processing gtf file\n"
for f in  HTSeq.GFF_Reader( gff_file ):
   if f.type == "exonic_part":
      f.name = f.attr['gene_id'] + ":" + f.attr[opts.region]
      features[f.iv] += f
      tname = f.attr['gene_id'] + ":" + f.attr['exonic_part_number']
      transNames[f.name] = tname


# initialise counters
print "initializing count vector\n"

alternative = {}
for iv, s in features.steps():
   for f in s:
      alternative[ f.name ] = 0

#We need this little helper below:
def reverse_strand( s ):
   if s == "+":
      return "-"
   elif s == "-":
      return "+"
   else:
      raise SystemError, "illegal strand"

def map_read_pair(af, ar):
   rs1 = set()
   rs2 = set()
   rs = set()
   if af and ar and not af.aligned and not ar.aligned:
      return '_notaligned', '_notaligned'
   if af and ar and not af.aQual < minaqual and ar.aQual < minaqual:
      return '_lowaqual', '_lowaqual'
   if af and af.aligned and af.aQual >= minaqual and af.iv.chrom in features.chrom_vectors.keys():
      for cigop in af.cigar:
         if cigop.type != "M":
            continue
         if reverse:
            cigop.ref_iv.strand = reverse_strand( cigop.ref_iv.strand )
         for iv, s in features[cigop.ref_iv].steps():
            rs1 = rs1.union( s )
   if ar and ar.aligned and ar.aQual >= minaqual and ar.iv.chrom in features.chrom_vectors.keys():
      for cigop in ar.cigar:
         if cigop.type != "M":
            continue
         if not reverse:
            cigop.ref_iv.strand = reverse_strand( cigop.ref_iv.strand )
         for iv, s in features[cigop.ref_iv].steps():
            rs2 = rs2.union( s )
   rs = rs1.union(rs2)
   set_of_gene_names = set( [ f.name.split(":")[0] for f in rs ] )
   if len( set_of_gene_names ) == 0:
      return '_empty', '_empty'
   elif len( set_of_gene_names ) > 1:
      return '_ambiguous', '_ambiguous'
   else:
      return rs1, rs2


def clean_read_queue( queue, current_position ):
   clean_queue = dict( queue )
   for i in queue:
      if queue[i].mate_start.pos < current_position:
         warnings.warn( "Read "+ i + " claims to have an aligned mate that could not be found in the same chromosome." )
         del clean_queue[i]
   return clean_queue


def identify_jumped_regions( rs ):
   cont=1
   length = len( rs )
   wmatches = list()
   toAdd = set()
   if length < 2:
      return toAdd
   for f in sorted( rs ):
      thisExon=f.name
      thisNumber=int(thisExon.split(":")[1])
      wmatches.append(thisNumber)
      thisGene=thisExon.split(":")[0]
      if cont == 1:
         firstNumber = thisNumber
      if cont == length:
         lastNumber = thisNumber
      cont=cont+1
   if abs(firstNumber - lastNumber) > 1:
      if lastNumber < firstNumber:
         tmp = lastNumber
         lastNumber = firstNumber
         firstNumber = tmp
      ranges = range( firstNumber, lastNumber+1)
      toAdd = set(ranges).difference(set(wmatches))
   return toAdd

def update_count_vector( alternative, thisGene, toAdd ):
   for m in toAdd:
      stm = str(m)
      while len(stm) < 3:
         stm = "0" + stm
      thisAlternative=thisGene+":"+stm
      if thisAlternative in alternative:
#      if transNames[thisAlternative] == "ENSG00000000460:018i":
#         print a.get_sam_line()
         alternative[thisAlternative] += 1
   return alternative


camara = HTSeq.BAM_Reader( sam_file )

# Now go through the aligned reads
if not is_PE:

   num_reads = 0
   for a in camara:
      if not a.aligned:
         continue
      rs = set()
      for cigop in a.cigar:
         if cigop.type != "M":
            continue
         if reverse:
            cigop.ref_iv.strand = reverse_strand( cigop.ref_iv.strand )
         for iv, s in features[cigop.ref_iv].steps( ):
            rs = rs.union( s )
      set_of_gene_names = set( [ f.name.split(":")[0] for f in rs ] )
      if len( set_of_gene_names ) == 0:
         continue
      elif len( set_of_gene_names ) > 1:
         continue
      elif len( rs ) > 1:
         thisGene = list(set_of_gene_names)[0]
         toAdd = identify_jumped_regions( rs )
         if len( toAdd ) == 0:
            continue
         alternative = update_count_vector( alternative, thisGene, toAdd )
      num_reads += 1
      if num_reads % 100000 == 0:
         sys.stderr.write( "%d reads processed.\n" % num_reads )

else:
#   print "treating as paired end"
   processed_chromosomes = dict()
   alignments = dict()
   num_reads = 0
   current_chromosome=''
   current_position=''
   for a in camara:
      if a.optional_field("NH") > 1:
         continue
      if current_chromosome != a.iv.chrom:
         if current_chromosome in processed_chromosomes:
            raise SystemError, "A chromosome that had finished to be processed before was found again in the alignment file, is your alignment file properly sorted by position?"
         processed_chromosomes[current_chromosome] = 1
         alignments = clean_read_queue( alignments, current_position )
         del alignments
         alignments = dict()
      if current_chromosome == a.iv.chrom and a.iv.start < current_position:
         raise SystemError, "Current read position is smaller than previous reads, is your alignment file properly sorted by position?"
      current_chromosome = a.iv.chrom
      current_position = a.iv.start
      if a.read.name and a.mate_aligned:
         if a.read.name in alignments:
            b = alignments[ a.read.name ]
            if a.pe_which == "first" and b.pe_which == "second":
               af=a
               ar=b
            else:
               af=b
               ar=a
            rs1, rs2 = map_read_pair(af, ar)
            del alignments[ a.read.name ]
            if type(rs1) == str or type( rs2 ) == str:
               continue
            rs = rs1.union(rs2)
            set_of_gene_names = set( [ f.name.split(":")[0] for f in rs ] )
            thisGene = list(set_of_gene_names)[0]
            if len(rs1) > 1:
               toAdd1 = identify_jumped_regions( rs1 )
            else:
               toAdd1 = set()
            if len(rs2) > 1:
               toAdd2 = identify_jumped_regions( rs2 )
            else:
               toAdd2 = set()
            toAdd = toAdd1.union(toAdd2)
            if len( toAdd ) == 0:
               continue
            alternative = update_count_vector( alternative, thisGene, toAdd )
         else:
            if a.mate_start.chrom != a.iv.chrom:
               continue
            else:
               alignments[ a.read.name ] = a
      else:
         print a.read.name
         continue
      num_reads += 1
      if num_reads % 200000 == 0:
         alignments = clean_read_queue( alignments, current_position )
         sys.stderr.write( "%d reads processed.\n" % (num_reads / 2) )



fout = open( out_alternative, "w" )
for fn in sorted( alternative.keys() ):
   fout.write( "%s\t%d\n" % ( transNames[fn], alternative[fn] ) )

fout.close()

